This project has two main part, BWT encode and backward search, which is bwtencode.cpp file and bwtsearch.cpp file respectively.

BWT encode
The aim of this part is to convert text file split by a given delimiter into a BWT file. 
1. Bucket sort is used. 128 buckets are created for characters whose ASCII codes are from 0 to 127. At this step, 128 buckets are actually 128 files while file names are ASCII values and integer type positions are stored in the buckets in binary form. Notice that we need to create these 128 buckets in the temporary folder at the very beginning, so we only need to do fopen 128 times. It will affect the performance quite a lot if we do fopen for every character when the original files are very large. Although for some small original files, not all of 128 characters will occur and some buckets might not be used at all. 
2. For each bucket, what needs to be done is sorting the suffix arrays by quicksort. (1) Here we need a specific struct to represent each suffix array. In each struct, there is char pointer pointing to the character at this position and an integer value to remember the position of this character. (2) Then, sort this struct array. Notice that, as we want to make sure that order of delimiters in the suffix array is the same as that in the original file, we need to overwrite the comparing function. Specifically, when the prefixes of two demisters are same, we just need to compare their positions in the original file instead of comparing their next characters. (3)After quicksort, we could write BWT files. At the same time, if we encounter a delimiter, we should also write the index of this delimiter into auxiliary position files.
3. In the end, it is always a good habit to free memory, remove redundant files and close files.

Backward search
This part includes 4 different type of search. Firstly, we need to build a c_table. Secondly, we must implement occ function(rank function). To speed up the calculation of occ function, we could count the amount of each character for every specific size of a block and store these numbers into a two dimension array. For instance, if the size of a BWT file is 4MB, then we could store how many characters there are in the first 1MB, then in the second 1MB and so on.
1. -m backward search. Count the total number of matching substrings (duplicates). Using the backward search algorithm given by week6 lecture notes.
2. -n backward search. Count the total number of matching substrings (no duplicates).  Using the backward search algorithm given by week6 lecture notes. What is more, for every matched record, we need to find its identifier and record its position into a set(to distinct these values). Then the size of this set is the result.
3. -a backward search. Output the sorted and unique record identifiers (no duplicates) which contains the matching string. Compare to -n backward search, the difference is that we need to output the elements in the set in order instead of the size.
4. -i backward search. Search for the records with their identifiers beginning with i and ending with j. As we sort the delimiters in the ascending order like original files in suffix arrays, so it will be easy to find identifiers from i to j. Then, according to the identifiers, do the backward search and find the required records.